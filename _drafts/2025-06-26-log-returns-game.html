<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Returns Arcade</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #00aaff;
            --secondary-color: #ff44cc;
            --text-color: #f0f0f0;
            --container-bg: #2a2a2a;
            --success-color: #00ff7f;
            --error-color: #ff3366;
            --neutral-color: #444;
        }
        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .game-container {
            width: 95%;
            max-width: 900px;
            background: var(--container-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        h1 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 10px;
        }
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .stat-value { font-weight: bold; }
        #active-bonus-container {
            background: #222;
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
        }
        #active-bonus-text {
            color: var(--secondary-color);
            animation: pulse-text 1.5s infinite;
        }
        @keyframes pulse-text {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        .choice-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 15px;
            position: relative;
        }
        .choice-option {
            flex: 1;
            background: #333;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }
        .choice-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .distribution-chart {
            width: 100%;
            height: 150px;
            border-radius: 5px;
            background: #222;
        }
        .choice-text-display {
            font-size: 3em;
            font-weight: bold;
        }
        .expected-log-return {
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 10px;
        }
        #wealth-chart-container {
            flex-grow: 1;
            margin-top: 10px;
        }
        #wealth-chart {
            width: 100%;
            height: 100%;
            min-height: 150px;
            border-radius: 5px;
        }
        .game-over-screen, .start-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.2em;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: var(--secondary-color);
        }
        #about-button {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 10px;
            font-size: 0.9em;
        }
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
            text-align: left;
            border: 1px solid var(--neutral-color);
        }
        .modal-content h2 { color: var(--primary-color); }
        .modal-content ul { padding-left: 20px; }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container" id="game-container">
        <div class="start-screen" id="start-screen">
            <h1>Log Returns Arcade</h1>
            <p>Choose the option with the highest expected return to maximize your wealth.</p>
            <p>Your previous choice continuously adds to your wealth, but its effect decays over time. Choose quickly!</p>
            <br>
            <button id="start-button">Start Game</button>
        </div>
    </div>

    <script>
    const GAME_HTML = `
        <button id="about-button">About</button>
        <h1>Log Returns Arcade</h1>
        <div class="game-stats">
            <div>Round: <span id="round-counter" class="stat-value">1</span></div>
            <div>Wealth: <span id="wealth-display" class="stat-value">0</span></div>
            <div>Streak: <span id="streak" class="stat-value">0</span></div>
        </div>
        <div id="active-bonus-container">Active Bonus: <span id="active-bonus-text">None</span></div>
        <div class="choice-container" id="choice-container">
            <div class="choice-option" id="option-a">
                <canvas class="distribution-chart" id="chart-a"></canvas>
                <div class="choice-text-display" id="text-display-a"></div>
                <div class="expected-log-return" id="log-return-a"></div>
            </div>
            <div class="choice-option" id="option-b">
                <canvas class="distribution-chart" id="chart-b"></canvas>
                <div class="choice-text-display" id="text-display-b"></div>
                <div class="expected-log-return" id="log-return-b"></div>
            </div>
        </div>
        <div id="wealth-chart-container">
            <canvas id="wealth-chart"></canvas>
        </div>
        <div id="about-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>About Log Returns Arcade</h2>
                <p>This game is an experiment in building intuition about expected log returns and compounding. The goal is to maximize your wealth by always choosing the option with the highest expected return.</p>
                <h3>Core Mechanics</h3>
                <ul>
                    <li><strong>Continuous Decay:</strong> After you make a choice, it becomes your "Active Bonus". This bonus continuously adds to your wealth, but its effect decays over time. The faster you make your next decision, the more value you extract.</li>
                    <li><strong>Multiple Operations:</strong> The game presents different types of choices: simple addition (+), simple multiplication (x), and choices based on probability distributions (PDF/CDF), which add an element of uncertainty.</li>
                </ul>
                <p>This version of the game was developed iteratively with a large language model.</p>
                <button id="close-about-modal">Close</button>
            </div>
        </div>
    `;

    class ChoiceFactory {
        generateMultiplierPdfChoice() {
            const n = 100, xMin = Math.log(0.1), xMax = Math.log(4);
            const xs = Array.from({ length: n }, (_, i) => xMin + (i / (n - 1)) * (xMax - xMin));
            const mode = Math.floor(Math.random() * (n * 0.6)) + n * 0.2;
            let ps = Array.from({ length: n }, (_, i) => {
                const dist = Math.abs(i - mode);
                return Math.exp(-Math.pow(dist / (n * 0.1), 2));
            });
            const area = ps.reduce((sum, p, i) => {
                if (i === 0) return 0;
                return sum + (p + ps[i-1]) / 2 * (xs[i] - xs[i-1]);
            }, 0);
            const normPs = ps.map(p => p / area);
            let expectedLogReturn = null;
            const computeLogReturn = () => {
                if (expectedLogReturn !== null) return expectedLogReturn;
                expectedLogReturn = normPs.reduce((sum, p, i) => {
                    if (i === 0) return 0;
                    return sum + ((xs[i]*p + xs[i-1]*normPs[i-1])/2) * (xs[i] - xs[i-1]);
                }, 0);
                return expectedLogReturn;
            };
            const cdfPoints = [];
            let acc = 0;
            for(let i=0; i<normPs.length; i++) {
                acc += normPs[i] * (i > 0 ? (xs[i] - xs[i-1]) : 0);
                cdfPoints.push(acc);
            }
            const maxCdf = cdfPoints.at(-1);
            const normalizedCdf = cdfPoints.map(p => p / maxCdf);
            const sample = () => Math.exp(xs[normalizedCdf.findIndex(p => Math.random() <= p)]);
            return { type: 'pdf', xs, ps: normPs, cdf: normalizedCdf, sample, getExpectedLogReturn: computeLogReturn, display: 'PDF' };
        }
        generateAdditionChoice() {
            const value = Math.floor(Math.random() * 100) + 1;
            return { type: 'add', value, display: `+${value}`, sample: () => value, getExpectedLogReturn: () => value };
        }
        generateSimpleMultiplierChoice() {
            const value = 1 + Math.random();
            return { type: 'multiply', value, display: `x${value.toFixed(2)}`, sample: () => value, getExpectedLogReturn: () => Math.log(value) };
        }
    }

    class Game {
        constructor() {
            this.gameContainer = document.getElementById('game-container');
            this.startButton = document.getElementById('start-button');
            this.choiceFactory = new ChoiceFactory();
            this.wealthChartInstance = null;
            this.state = {};
            this.loadDependencies();
        }

        loadDependencies() {
            this.startButton.disabled = true;
            this.startButton.textContent = 'Loading...';
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
            script.onload = () => {
                this.startButton.disabled = false;
                this.startButton.textContent = 'Start Game';
                this.startButton.addEventListener('click', () => this.startGame());
            };
            document.head.appendChild(script);
        }

        startGame() {
            this.gameContainer.innerHTML = GAME_HTML;
            this.DOM = {
                roundCounter: document.getElementById('round-counter'),
                wealthDisplay: document.getElementById('wealth-display'),
                streak: document.getElementById('streak'),
                activeBonusText: document.getElementById('active-bonus-text'),
                optionA: document.getElementById('option-a'),
                optionB: document.getElementById('option-b'),
                chartA: document.getElementById('chart-a'),
                chartB: document.getElementById('chart-b'),
                textDisplayA: document.getElementById('text-display-a'),
                textDisplayB: document.getElementById('text-display-b'),
                logReturnA: document.getElementById('log-return-a'),
                logReturnB: document.getElementById('log-return-b'),
                wealthChart: document.getElementById('wealth-chart'),
                aboutButton: document.getElementById('about-button'),
                aboutModal: document.getElementById('about-modal'),
                closeAboutModal: document.getElementById('close-about-modal'),
            };
            this.resetGame();
        }

        resetGame() {
            if (this.state.decayInterval) clearInterval(this.state.decayInterval);
            this.state = {
                round: 1,
                streak: 0,
                currentChoices: null,
                activeDecayChoice: null,
                decayInterval: null,
                decayStartTime: 0,
                playerWealth: [1],
                optimalWealth: [1],
                worstWealth: [1],
            };
            if (this.wealthChartInstance) this.wealthChartInstance.destroy();
            this.setupWealthChart();
            this.addEventListeners();
            this.nextRound();
        }

        addEventListeners() {
            this.DOM.optionA.addEventListener('click', () => this.selectOption('A'));
            this.DOM.optionB.addEventListener('click', () => this.selectOption('B'));
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') this.selectOption('A');
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') this.selectOption('B');
            });
            this.DOM.aboutButton.addEventListener('click', () => this.DOM.aboutModal.classList.remove('hidden'));
            this.DOM.closeAboutModal.addEventListener('click', () => this.DOM.aboutModal.classList.add('hidden'));
        }

        nextRound() {
            if (this.state.round > 20) {
                this.endGame();
                return;
            }
            this.state.currentChoices = this.generateChoicePair();
            this.updateDisplay();
        }

        selectOption(optionKey) {
            if (!this.state.currentChoices) return;
            if (this.state.decayInterval) clearInterval(this.state.decayInterval);

            this.updateWealth(true);

            const selectedChoice = this.state.currentChoices[optionKey];
            this.state.activeDecayChoice = selectedChoice;
            this.DOM.activeBonusText.textContent = selectedChoice.display;

            const { A, B } = this.state.currentChoices;
            const optimalChoiceKey = A.getExpectedLogReturn() > B.getExpectedLogReturn() ? 'A' : 'B';
            const worstChoiceKey = optimalChoiceKey === 'A' ? 'B' : 'A';
            if (optionKey === optimalChoiceKey) this.state.streak++;
            else this.state.streak = 0;

            const choiceType = selectedChoice.type;
            const optimalReturn = this.state.currentChoices[optimalChoiceKey].sample();
            const worstReturn = this.state.currentChoices[worstChoiceKey].sample();
            this.state.optimalWealth.push(this.updateWealthValue(this.state.optimalWealth.at(-1), optimalReturn, choiceType));
            this.state.worstWealth.push(this.updateWealthValue(this.state.worstWealth.at(-1), worstReturn, choiceType));

            this.state.playerWealth.push(this.state.playerWealth.at(-1));

            this.state.round++;
            this.startDecayProcess();
            this.nextRound();
        }

        updateWealthValue(base, returnValue, type) {
            if (type === 'add') return base + returnValue;
            return base * (returnValue || 1);
        }

        startDecayProcess() {
            if (!this.state.activeDecayChoice) return;
            this.state.decayStartTime = Date.now();
            this.state.decayInterval = setInterval(() => this.updateWealth(), 100);
        }

        updateWealth(isFinal = false) {
            const elapsedTime = Date.now() - this.state.decayStartTime;
            const decayRate = 3000; // ms
            const decay = Math.max(0, 1 - (elapsedTime / decayRate));

            const choice = this.state.activeDecayChoice;
            if (!choice) return;

            const rawSample = choice.sample();
            let effectiveSample;

            if (choice.type === 'add') {
                effectiveSample = rawSample * decay * 0.1; // Scale down additive bonus
            } else { // multiply, pdf, cdf
                effectiveSample = (rawSample - 1) * decay + 1;
            }
            
            const lastIdx = this.state.playerWealth.length - 1;
            this.state.playerWealth[lastIdx] = this.updateWealthValue(this.state.playerWealth[lastIdx], effectiveSample, choice.type);

            this.DOM.wealthDisplay.textContent = this.state.playerWealth.at(-1).toFixed(2);
            this.wealthChartInstance.data.labels = Array.from({ length: this.state.playerWealth.length }, (_, i) => i);
            this.wealthChartInstance.update('none');

            if (isFinal) {
                this.wealthChartInstance.update();
            }
        }

        updateDisplay() {
            this.DOM.roundCounter.textContent = this.state.round;
            this.DOM.wealthDisplay.textContent = this.state.playerWealth.at(-1).toFixed(2);
            this.DOM.streak.textContent = this.state.streak;

            if (!this.state.currentChoices) return;
            const { A, B } = this.state.currentChoices;
            
            const updateOptionUI = (option, id) => {
                const chartEl = this.DOM[`chart${id}`];
                const textEl = this.DOM[`textDisplay${id}`];
                const logReturnEl = this.DOM[`logReturn${id}`];

                if (option.type === 'pdf' || option.type === 'cdf') {
                    chartEl.classList.remove('hidden');
                    textEl.classList.add('hidden');
                    this.drawDistribution(chartEl, option);
                    logReturnEl.textContent = `E[log(R)] = ${option.getExpectedLogReturn().toFixed(3)}`;
                } else {
                    chartEl.classList.add('hidden');
                    textEl.classList.remove('hidden');
                    textEl.textContent = option.display;
                    logReturnEl.textContent = option.type === 'add' ? `Value: ${option.value}` : `E[log(R)] = ${option.getExpectedLogReturn().toFixed(3)}`;
                }
            };
            updateOptionUI(A, 'A');
            updateOptionUI(B, 'B');
        }

        generateChoicePair() {
            const choiceTypes = ['pdf', 'add', 'multiply', 'cdf'];
            const selectedType = choiceTypes[Math.floor(Math.random() * choiceTypes.length)];
            let choiceA, choiceB;
            if (selectedType === 'pdf' || selectedType === 'cdf') {
                choiceA = this.choiceFactory.generateMultiplierPdfChoice();
                choiceB = this.choiceFactory.generateMultiplierPdfChoice();
                if (selectedType === 'cdf') {
                    choiceA.type = 'cdf';
                    choiceB.type = 'cdf';
                }
            } else if (selectedType === 'add') {
                choiceA = this.choiceFactory.generateAdditionChoice();
                choiceB = this.choiceFactory.generateAdditionChoice();
            } else if (selectedType === 'multiply') {
                choiceA = this.choiceFactory.generateSimpleMultiplierChoice();
                choiceB = this.choiceFactory.generateSimpleMultiplierChoice();
            }
            if (choiceA.getExpectedLogReturn() === choiceB.getExpectedLogReturn()) return this.generateChoicePair();
            return { A: choiceA, B: choiceB };
        }

        drawDistribution(canvas, distribution) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            ctx.clearRect(0, 0, width, height);
            const { xs, ps, cdf, type } = distribution;
            const margin = { top: 10, right: 10, bottom: 20, left: 10 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            const dataToDraw = type === 'cdf' ? cdf : ps;
            const maxVal = type === 'cdf' ? 1 : Math.max(...ps);
            const minXs = xs[0], maxXs = xs.at(-1);
            ctx.beginPath();
            ctx.strokeStyle = type === 'cdf' ? 'var(--secondary-color)' : 'var(--primary-color)';
            ctx.lineWidth = 2;
            for (let i = 0; i < xs.length; i++) {
                const x = margin.left + ((xs[i] - minXs) / (maxXs - minXs)) * plotWidth;
                const y = height - margin.bottom - (dataToDraw[i] / maxVal) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            if (minXs < 0 && maxXs > 0) {
                const breakEvenX = margin.left + (-minXs / (maxXs - minXs)) * plotWidth;
                ctx.strokeStyle = 'var(--error-color)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(breakEvenX, margin.top);
                ctx.lineTo(breakEvenX, height - margin.bottom);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        setupWealthChart() {
            const labels = Array.from({ length: this.state.playerWealth.length }, (_, i) => i);
            const ctx = this.DOM.wealthChart.getContext('2d');
            this.wealthChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Your Wealth', data: this.state.playerWealth, borderColor: '#00aaff', tension: 0.1, pointRadius: 0 },
                        { label: 'Optimal Wealth', data: this.state.optimalWealth, borderColor: '#00ff7f', tension: 0.1, pointRadius: 0 },
                        { label: 'Worst Wealth', data: this.state.worstWealth, borderColor: '#ff3366', tension: 0.1, pointRadius: 0 },
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { y: { type: 'logarithmic', ticks: { color: 'var(--text-color)' }, grid: { color: 'rgba(255,255,255,0.1)' } }, x: { ticks: { color: 'var(--text-color)' }, grid: { color: 'rgba(255,255,255,0.1)' } } },
                    plugins: { legend: { labels: { color: 'var(--text-color)' } } }
                }
            });
        }

        endGame() {
            if (this.state.decayInterval) clearInterval(this.state.decayInterval);
            const finalPlayerWealth = this.state.playerWealth.at(-1);
            const finalOptimalWealth = this.state.optimalWealth.at(-1);
            const finalWorstWealth = this.state.worstWealth.at(-1);

            this.gameContainer.innerHTML = `
                <div class="game-over-screen">
                    <h1>Game Over!</h1>
                    <h3>Final Wealth:</h3>
                    <p style="color: #00aaff;">Your Strategy: ${finalPlayerWealth.toFixed(2)}</p>
                    <p style="color: #00ff7f;">Optimal Strategy: ${finalOptimalWealth.toFixed(2)}</p>
                    <p style="color: #ff3366;">Worst Strategy: ${finalWorstWealth.toFixed(2)}</p>
                    <br>
                    <button id="play-again">Play Again</button>
                </div>
            `;
            document.getElementById('play-again').addEventListener('click', () => this.startGame());
        }
    }

    new Game();
    </script>
</body>
</html>
