<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Returns Arcade</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #00aaff;
            --secondary-color: #ff44cc;
            --text-color: #f0f0f0;
            --container-bg: #2a2a2a;
            --success-color: #00ff7f;
            --error-color: #ff3366;
            --neutral-color: #444;
        }
        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .game-container {
            width: 95%;
            max-width: 900px;
            background: var(--container-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        h1 {
            color: var(--primary-color);
            margin-top: 0;
        }
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        .stat-value { font-weight: bold; }
        .choice-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 15px;
            position: relative;
        }
        .choice-option {
            flex: 1;
            background: #333;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid transparent;
        }
        .choice-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .choice-option.selected {
            transform: scale(1.05);
        }
        .choice-option.correct {
            animation: flash-green 0.5s ease;
        }
        .choice-option.incorrect {
            animation: flash-red 0.5s ease;
        }
        @keyframes flash-green {
            0%, 100% { box-shadow: 0 0 15px var(--success-color); }
            50% { box-shadow: 0 0 30px var(--success-color); }
        }
        @keyframes flash-red {
            0%, 100% { box-shadow: 0 0 15px var(--error-color); }
            50% { box-shadow: 0 0 30px var(--error-color); }
        }
        .distribution-chart {
            width: 100%;
            height: 150px;
            border-radius: 5px;
            background: #222;
        }
        .expected-log-return {
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 10px;
        }
        .feedback-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .feedback-overlay.show { opacity: 1; }
        #wealth-chart-container {
            flex-grow: 1;
            margin-top: 10px;
        }
        #wealth-chart {
            width: 100%;
            height: 100%;
            min-height: 150px;
            border-radius: 5px;
        }
        .game-over-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.2em;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: var(--secondary-color);
        }
    </style>
</head>
<body>
    <div class="game-container" id="game-container">
        <h1>Log Returns Arcade</h1>
        <div class="game-stats">
            <div>Round: <span id="round-counter" class="stat-value">1</span></div>
            <div>Score: <span id="score" class="stat-value">0</span></div>
            <div>Streak: <span id="streak" class="stat-value">0</span></div>
        </div>
        <div class="choice-container" id="choice-container">
            <div class="choice-option" id="option-a">
                <canvas class="distribution-chart" id="chart-a"></canvas>
                <div class="expected-log-return" id="log-return-a"></div>
            </div>
            <div class="choice-option" id="option-b">
                <canvas class="distribution-chart" id="chart-b"></canvas>
                <div class="expected-log-return" id="log-return-b"></div>
            </div>
            <div class="feedback-overlay" id="feedback-overlay"></div>
        </div>
        <div id="wealth-chart-container">
            <canvas id="wealth-chart"></canvas>
        </div>
    </div>

    <script>
    class Game {
        constructor() {
            this.DOM = {
                gameContainer: document.getElementById('game-container'),
                roundCounter: document.getElementById('round-counter'),
                score: document.getElementById('score'),
                streak: document.getElementById('streak'),
                choiceContainer: document.getElementById('choice-container'),
                optionA: document.getElementById('option-a'),
                optionB: document.getElementById('option-b'),
                chartA: document.getElementById('chart-a'),
                chartB: document.getElementById('chart-b'),
                logReturnA: document.getElementById('log-return-a'),
                logReturnB: document.getElementById('log-return-b'),
                feedbackOverlay: document.getElementById('feedback-overlay'),
                wealthChart: document.getElementById('wealth-chart'),
            };

            this.config = {
                maxRounds: 20,
            };

            this.wealthChartInstance = null;
            this.resetGame();
            this.addEventListeners();
        }

        resetGame() {
            this.state = {
                round: 1,
                score: 0,
                streak: 0,
                isRoundActive: false,
                currentDistributions: null,
                playerWealth: [1],
                optimalWealth: [1],
                worstWealth: [1],
            };

            if (this.wealthChartInstance) {
                this.wealthChartInstance.destroy();
            }
            this.setupWealthChart();
            this.startRound();
        }

        addEventListeners() {
            this.DOM.optionA.addEventListener('click', () => this.selectOption('A'));
            this.DOM.optionB.addEventListener('click', () => this.selectOption('B'));
            document.addEventListener('keydown', (e) => {
                if (!this.state.isRoundActive) return;
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') this.selectOption('A');
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') this.selectOption('B');
            });
        }

        startRound() {
            if (this.state.round > this.config.maxRounds) {
                this.endGame();
                return;
            }

            this.state.isRoundActive = true;
            this.state.currentDistributions = this.generateDistributions();
            
            this.DOM.optionA.classList.remove('correct', 'incorrect', 'selected');
            this.DOM.optionB.classList.remove('correct', 'incorrect', 'selected');
            this.DOM.feedbackOverlay.classList.remove('show');

            this.updateDisplay();
        }

        selectOption(option) {
            if (!this.state.isRoundActive) return;
            this.DOM[`option${option}`].classList.add('selected');
            this.handleChoice(option);
        }

        handleChoice(selectedOption) {
            this.state.isRoundActive = false;

            const { A, B } = this.state.currentDistributions;
            const optimalChoice = A.getExpectedLogReturn() > B.getExpectedLogReturn() ? 'A' : 'B';
            const worstChoice = optimalChoice === 'A' ? 'B' : 'A';
            const isCorrect = selectedOption === optimalChoice;

            if (isCorrect) {
                this.state.score++;
                this.state.streak++;
                this.DOM.feedbackOverlay.textContent = '✓';
                this.DOM.feedbackOverlay.style.color = 'var(--success-color)';
            } else {
                this.state.streak = 0;
                this.DOM.feedbackOverlay.textContent = '✗';
                this.DOM.feedbackOverlay.style.color = 'var(--error-color)';
            }
            this.DOM.feedbackOverlay.classList.add('show');
            
            const selectedDist = selectedOption ? this.state.currentDistributions[selectedOption] : null;
            const optimalDist = this.state.currentDistributions[optimalChoice];
            const worstDist = this.state.currentDistributions[worstChoice];

            const playerReturn = selectedDist ? selectedDist.sample() : 1; // Default to 1 if no choice
            const optimalReturn = optimalDist.sample();
            const worstReturn = worstDist.sample();

            this.state.playerWealth.push(this.state.playerWealth.at(-1) * playerReturn);
            this.state.optimalWealth.push(this.state.optimalWealth.at(-1) * optimalReturn);
            this.state.worstWealth.push(this.state.worstWealth.at(-1) * worstReturn);

            this.DOM[`option${optimalChoice}`].classList.add('correct');
            if (selectedOption && !isCorrect) {
                this.DOM[`option${selectedOption}`].classList.add('incorrect');
            }

            this.updateWealthChart();
            this.updateDisplay();

            setTimeout(() => {
                this.state.round++;
                this.startRound();
            }, 500);
        }

        updateDisplay() {
            this.DOM.roundCounter.textContent = this.state.round;
            this.DOM.score.textContent = this.state.score;
            this.DOM.streak.textContent = this.state.streak;

            const { A, B } = this.state.currentDistributions;
            this.DOM.logReturnA.textContent = `E[log(R)] = ${A.getExpectedLogReturn().toFixed(3)}`;
            this.DOM.logReturnB.textContent = `E[log(R)] = ${B.getExpectedLogReturn().toFixed(3)}`;

            this.drawDistribution(this.DOM.chartA, A);
            this.drawDistribution(this.DOM.chartB, B);
        }

        generateDistributions() {
            const distA = this.generateLogReturnPDF();
            const distB = this.generateLogReturnPDF();
            // Ensure they are not too similar
            if (Math.abs(distA.getExpectedLogReturn() - distB.getExpectedLogReturn()) < 0.01) {
                return this.generateDistributions();
            }
            return { A: distA, B: distB };
        }

        generateLogReturnPDF(n = 100, xMin = Math.log(0.1), xMax = Math.log(4)) {
            const xs = Array.from({ length: n }, (_, i) => xMin + (i / (n - 1)) * (xMax - xMin));
            const mode = Math.floor(Math.random() * (n * 0.6)) + n * 0.2; // Peak between 20% and 80%

            let ps = Array.from({ length: n }, (_, i) => {
                const dist = Math.abs(i - mode);
                return Math.exp(-Math.pow(dist / (n * 0.1), 2));
            });

            const area = ps.reduce((sum, p, i) => {
                if (i === 0) return 0;
                const dx = xs[i] - xs[i-1];
                return sum + (p + ps[i-1]) / 2 * dx;
            }, 0);
            
            const normPs = ps.map(p => p / area);

            let expectedLogReturn = null;
            const computeLogReturn = () => {
                if (expectedLogReturn !== null) return expectedLogReturn;
                expectedLogReturn = normPs.reduce((sum, p, i) => {
                    if (i === 0) return 0;
                    const dx = xs[i] - xs[i-1];
                    const avg_x_p = (xs[i]*p + xs[i-1]*ps[i-1])/2;
                    return sum + avg_x_p * dx;
                }, 0);
                return expectedLogReturn;
            };

            const cdf = normPs.map((p, i) => ({p: p * (i > 0 ? (xs[i] - xs[i-1]) : 0), x: xs[i]}));
            let acc = 0;
            for(let i=0; i<cdf.length; i++) { cdf[i].p = acc += cdf[i].p; }
            const maxCdf = cdf.at(-1).p;

            const sample = () => {
                const u = Math.random() * maxCdf;
                const sampleIdx = cdf.findIndex(val => u <= val.p);
                return Math.exp(xs[sampleIdx]);
            };

            return { xs, ps: normPs, sample, getExpectedLogReturn: computeLogReturn };
        }

        drawDistribution(canvas, distribution) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            ctx.clearRect(0, 0, width, height);

            const { xs, ps } = distribution;
            const margin = { top: 10, right: 10, bottom: 20, left: 10 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const maxPs = Math.max(...ps);
            const minXs = xs[0];
            const maxXs = xs.at(-1);

            // Draw curve
            ctx.beginPath();
            ctx.strokeStyle = 'var(--primary-color)';
            ctx.lineWidth = 2;
            for (let i = 0; i < xs.length; i++) {
                const x = margin.left + ((xs[i] - minXs) / (maxXs - minXs)) * plotWidth;
                const y = height - margin.bottom - (ps[i] / maxPs) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw break-even line
            if (minXs < 0 && maxXs > 0) {
                const breakEvenX = margin.left + (-minXs / (maxXs - minXs)) * plotWidth;
                ctx.strokeStyle = 'var(--error-color)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(breakEvenX, margin.top);
                ctx.lineTo(breakEvenX, height - margin.bottom);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        setupWealthChart() {
            const ctx = this.DOM.wealthChart.getContext('2d');
            this.wealthChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [0],
                    datasets: [
                        {
                            label: 'Your Wealth',
                            data: [1],
                            borderColor: '#00aaff',
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'Optimal Wealth',
                            data: [1],
                            borderColor: '#00ff7f',
                            tension: 0.1,
                            pointRadius: 0,
                        },
                        {
                            label: 'Worst Wealth',
                            data: [1],
                            borderColor: '#ff3366',
                            tension: 0.1,
                            pointRadius: 0,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'logarithmic',
                            ticks: { color: 'var(--text-color)' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: 'var(--text-color)' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: 'var(--text-color)' }
                        }
                    }
                }
            });
        }

        updateWealthChart() {
            const labels = Array.from({ length: this.state.playerWealth.length }, (_, i) => i);
            this.wealthChartInstance.data.labels = labels;
            this.wealthChartInstance.data.datasets[0].data = this.state.playerWealth;
            this.wealthChartInstance.data.datasets[1].data = this.state.optimalWealth;
            this.wealthChartInstance.data.datasets[2].data = this.state.worstWealth;
            this.wealthChartInstance.update('none');
        }

        endGame() {
            const accuracy = (this.state.score / this.config.maxRounds * 100).toFixed(1);
            const finalPlayerWealth = this.state.playerWealth.at(-1);
            const finalOptimalWealth = this.state.optimalWealth.at(-1);
            const finalWorstWealth = this.state.worstWealth.at(-1);

            this.DOM.gameContainer.innerHTML = `
                <div class="game-over-screen">
                    <h1>Game Over!</h1>
                    <p>Final Score: ${this.state.score} / ${this.config.maxRounds} (${accuracy}%)</p>
                    <h3>Final Wealth Multiplier:</h3>
                    <p style="color: var(--primary-color);">Your Strategy: ${finalPlayerWealth.toFixed(2)}x</p>
                    <p style="color: var(--success-color);">Optimal Strategy: ${finalOptimalWealth.toFixed(2)}x</p>
                    <p style="color: var(--error-color);">Worst Strategy: ${finalWorstWealth.toFixed(2)}x</p>
                    <p>You achieved ${(finalPlayerWealth / finalOptimalWealth * 100).toFixed(1)}% of the optimal wealth.</p>
                    <br>
                    <button id="play-again">Play Again</button>
                </div>
            `;
            document.getElementById('play-again').addEventListener('click', () => {
                // This is a bit of a hack to reload the game state.
                // A more robust solution would re-initialize the game container.
                window.location.reload();
            });
        }
    }

    // Need to load Chart.js
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
    script.onload = () => {
        new Game();
    };
    document.head.appendChild(script);
    </script>
</body>
</html>
