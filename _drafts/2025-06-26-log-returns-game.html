<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Returns Arcade</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #00aaff;
            --secondary-color: #ff44cc;
            --text-color: #f0f0f0;
            --container-bg: #2a2a2a;
            --success-color: #00ff7f;
            --error-color: #ff3366;
            --neutral-color: #444;
        }
        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .game-container {
            width: 95%;
            max-width: 900px;
            background: var(--container-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        h1 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 10px;
        }
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .stat-value { font-weight: bold; }
        #active-bonus-container {
            background: #222;
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
        }
        #active-bonus-text {
            color: var(--secondary-color);
            animation: pulse-text 1.5s infinite;
        }
        @keyframes pulse-text {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        .choice-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 15px;
            position: relative;
        }
        .choice-option {
            flex: 1;
            background: #333;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }
        .choice-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .distribution-chart {
            width: 100%;
            height: 150px;
            border-radius: 5px;
            background: #222;
        }
        .stock-chart {
            width: 100%;
            height: 150px;
            border-radius: 5px;
            background: #222;
        }
        .choice-text-display {
            font-size: 3em;
            font-weight: bold;
        }
        .expected-log-return {
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 10px;
        }
        #wealth-chart-container {
            flex-grow: 1;
            margin-top: 10px;
        }
        #wealth-chart {
            width: 100%;
            height: 100%;
            min-height: 150px;
            border-radius: 5px;
        }
        .game-over-screen, .start-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.2em;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: var(--secondary-color);
        }
        #about-button {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 10px;
            font-size: 0.9em;
        }
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
            text-align: left;
            border: 1px solid var(--neutral-color);
        }
        .modal-content h2 { color: var(--primary-color); }
        .modal-content ul { padding-left: 20px; }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container" id="game-container">
        <div class="start-screen" id="start-screen">
            <h1>Log Returns Arcade</h1>
            <p>Choose the option with the highest expected return to maximize your wealth.</p>
            <p>Your previous choice continuously adds to your wealth, but its effect decays over time. Choose quickly!</p>
            <br>
            <button id="start-button">Start Game</button>
        </div>
    </div>

    <script>
    const GAME_HTML = `
        <button id="about-button">About</button>
        <h1>Log Returns Arcade</h1>
        <div class="game-stats">
            <div>Round: <span id="round-counter" class="stat-value">1</span></div>
            <div>Wealth: <span id="wealth-display" class="stat-value">0</span></div>
            <div>Streak: <span id="streak" class="stat-value">0</span></div>
        </div>
        <div id="active-bonus-container">Active Bonus: <span id="active-bonus-text">None</span></div>
        <div class="choice-container" id="choice-container">
            <div class="choice-option" id="option-a">
                <canvas class="distribution-chart" id="chart-a"></canvas>
                <div class="choice-text-display" id="text-display-a"></div>
                <div class="expected-log-return" id="log-return-a"></div>
            </div>
            <div class="choice-option" id="option-b">
                <canvas class="distribution-chart" id="chart-b"></canvas>
                <div class="choice-text-display" id="text-display-b"></div>
                <div class="expected-log-return" id="log-return-b"></div>
            </div>
        </div>
        <div id="wealth-chart-container">
            <canvas id="wealth-chart"></canvas>
        </div>
        <div id="about-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>About Log Returns Arcade</h2>
                <p>This game is an experiment in building intuition about expected log returns and compounding. The goal is to maximize your wealth by always choosing the option with the highest expected return.</p>
                <h3>Core Mechanics</h3>
                <ul>
                    <li><strong>Continuous Decay:</strong> After you make a choice, it becomes your "Active Bonus". This bonus continuously adds to your wealth, but its effect decays over time. The faster you make your next decision, the more value you extract.</li>
                    <li><strong>Multiple Operations:</strong> The game presents different types of choices: simple addition (+), simple multiplication (x), and choices based on probability distributions (PDF/CDF), which add an element of uncertainty.</li>
                </ul>
                <h3>Math (SDE View)</h3>
                <p>Let <code>W(t)</code> be wealth and <code>f(t) ∈ [0,1]</code> be the decay envelope over each 3s window (starts at 1 and linearly drops to 0). The game runs at 10 ticks per second with step <code>dt = 0.1</code>s.</p>
                <ul>
                    <li><strong>Multiplicative choices (x, PDF/CDF, Empirical):</strong> per tick we sample a per-second gross return <code>M_t</code> and apply log-scaling: <code>d ln W = f(t) · r_t · dt</code>, where <code>r_t = ln M_t</code>. Implementation: <code>W ← W · exp(r_t · f(t) · dt)</code>. (We clamp <code>r_t</code> to a small band to avoid spikes.)</li>
                    <li><strong>Additive choices (+):</strong> with per-second rate <code>a</code>, we update: <code>dW = f(t) · a · dt</code>. Implementation: <code>W ← W + a · f(t) · dt</code>.</li>
                    <li><strong>Empirical stock:</strong> the per-second log-returns <code>r</code> are drawn from a GBM-like simulator calibrated to annual <code>μ ∈ [5%,9%]</code>, <code>σ ∈ [12%,20%]</code>, then sampled i.i.d. each tick to generate <code>M_t = exp(r)</code>.</li>
                </ul>
                <p>Approximation: for multiplicative choices you can view this as <code>d ln W = f(t)(μ dt + σ dB_t)</code> with <code>μ,σ</code> set by the chosen distribution (or empirically estimated), and the decay <code>f(t)</code> tapering the effect over a window.</p>
                <p>This version of the game was developed iteratively with a large language model.</p>
                <button id="close-about-modal">Close</button>
            </div>
        </div>
    `;

    // Game timing/scaling constants
    const TICK_MS = 100;
    const DECAY_MS = 3000;
    // Compresses one "market year" into this many real seconds of game time
    const GAME_SECONDS_PER_YEAR = 90; // even calmer, smoother pacing
    const INITIAL_WEALTH = 1000;

    class ChoiceFactory {
        // Helper to generate a random normal using Box-Muller
        #randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        generateMultiplierPdfChoice() {
            // x axis is log-returns (log multipliers) per second of game-time
            const n = 100, xMin = -0.03, xMax = 0.03; // narrow, stable per-second range
            const xs = Array.from({ length: n }, (_, i) => xMin + (i / (n - 1)) * (xMax - xMin));
            const mode = Math.floor(Math.random() * (n * 0.6)) + Math.floor(n * 0.2);
            let ps = Array.from({ length: n }, (_, i) => {
                const dist = Math.abs(i - mode);
                return Math.exp(-Math.pow(dist / (n * 0.12), 2));
            });
            const area = ps.reduce((sum, p, i) => {
                if (i === 0) return 0;
                return sum + (p + ps[i-1]) / 2 * (xs[i] - xs[i-1]);
            }, 0);
            const normPs = ps.map(p => p / area);
            let expectedLogReturn = null;
            const computeLogReturn = () => {
                if (expectedLogReturn !== null) return expectedLogReturn;
                expectedLogReturn = normPs.reduce((sum, p, i) => {
                    if (i === 0) return 0;
                    return sum + ((xs[i]*p + xs[i-1]*normPs[i-1])/2) * (xs[i] - xs[i-1]);
                }, 0);
                return expectedLogReturn;
            };
            const cdfPoints = [];
            let acc = 0;
            for(let i=0; i<normPs.length; i++) {
                acc += normPs[i] * (i > 0 ? (xs[i] - xs[i-1]) : 0);
                cdfPoints.push(acc);
            }
            const maxCdf = cdfPoints.at(-1);
            const normalizedCdf = cdfPoints.map(p => p / maxCdf);
            const sample = () => Math.exp(xs[normalizedCdf.findIndex(p => Math.random() <= p)]); // per-second multiplier
            return { type: 'pdf', xs, ps: normPs, cdf: normalizedCdf, sample, getExpectedLogReturn: computeLogReturn, display: 'PDF' };
        }
        generateEmpiricalStockChoice() {
            // Generate a synthetic stock path (GBM-like), then sample returns empirically
            const steps = 200;
            const startPrice = 100;
            // Annualized drift/vol, then convert to per-game-second using GAME_SECONDS_PER_YEAR
            const muAnnual = 0.05 + Math.random() * 0.04; // [5%, 9%]
            const sigmaAnnual = 0.12 + Math.random() * 0.08; // [12%, 20%]
            const dtSec = 1 / GAME_SECONDS_PER_YEAR; // one game-second is 1/60th of a year
            const prices = [startPrice];
            const logReturns = [];
            const multipliers = [];
            for (let i = 0; i < steps; i++) {
                const z = this.#randn();
                const lr = (muAnnual - 0.5 * sigmaAnnual * sigmaAnnual) * dtSec + sigmaAnnual * Math.sqrt(dtSec) * z; // per-second log-return
                const mult = Math.exp(lr);
                const next = prices[prices.length - 1] * mult;
                prices.push(next);
                logReturns.push(lr);
                multipliers.push(mult);
            }
            const avgLogRet = logReturns.reduce((a,b)=>a+b,0) / logReturns.length;
            const sample = () => multipliers[Math.floor(Math.random() * multipliers.length)]; // per-second multiplier
            return { type: 'empirical', prices, logReturns, multipliers, muAnnual, sigmaAnnual, sample, getExpectedLogReturn: () => avgLogRet, display: 'Stock' };
        }
        generateAdditionChoice() {
            const value = Math.floor(Math.random() * 13) + 3; // +3..+15
            return { type: 'add', value, display: `+${value}`, sample: () => value, getExpectedLogReturn: () => value };
        }
        generateSimpleMultiplierChoice() {
            const value = 0.995 + Math.random() * 0.01; // [0.995, 1.005] per-second multiplier
            return { type: 'multiply', value, display: `x${value.toFixed(3)}`, sample: () => value, getExpectedLogReturn: () => Math.log(value) };
        }
    }

    class Game {
        constructor() {
            this.gameContainer = document.getElementById('game-container');
            this.startButton = document.getElementById('start-button');
            this.choiceFactory = new ChoiceFactory();
            this.wealthChartInstance = null;
            this.state = {};
            // One-time key handler to avoid duplicates across restarts
            this.boundKeydown = (e) => {
                if (!this.DOM) return;
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') this.selectOption('A');
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') this.selectOption('B');
            };
            document.addEventListener('keydown', this.boundKeydown);
            this.loadDependencies();
        }

        loadDependencies() {
            this.startButton.disabled = true;
            this.startButton.textContent = 'Loading...';
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
            script.onload = () => {
                this.startButton.disabled = false;
                this.startButton.textContent = 'Start Game';
                this.startButton.addEventListener('click', () => this.startGame());
            };
            document.head.appendChild(script);
        }

        startGame() {
            this.gameContainer.innerHTML = GAME_HTML;
            this.DOM = {
                roundCounter: document.getElementById('round-counter'),
                wealthDisplay: document.getElementById('wealth-display'),
                streak: document.getElementById('streak'),
                activeBonusText: document.getElementById('active-bonus-text'),
                optionA: document.getElementById('option-a'),
                optionB: document.getElementById('option-b'),
                chartA: document.getElementById('chart-a'),
                chartB: document.getElementById('chart-b'),
                textDisplayA: document.getElementById('text-display-a'),
                textDisplayB: document.getElementById('text-display-b'),
                logReturnA: document.getElementById('log-return-a'),
                logReturnB: document.getElementById('log-return-b'),
                wealthChart: document.getElementById('wealth-chart'),
                aboutButton: document.getElementById('about-button'),
                aboutModal: document.getElementById('about-modal'),
                closeAboutModal: document.getElementById('close-about-modal'),
            };
            this.resetGame();
        }

        resetGame() {
            if (this.state.decayInterval) clearInterval(this.state.decayInterval);
            this.state = {
                round: 1,
                streak: 0,
                wealth: INITIAL_WEALTH,
                currentChoices: null,
                activeDecayChoice: null,
                activeAddRate: null,
                decayInterval: null,
                decayStartTime: Date.now(),
                totalTime: 0,
            };
            this.wealthHistory = [{ x: 0, y: INITIAL_WEALTH }];
            if (this.wealthChartInstance) this.wealthChartInstance.destroy();
            this.setupWealthChart();
            this.addEventListeners();
            this.nextRound();
        }

        addEventListeners() {
            this.DOM.optionA.addEventListener('click', () => this.selectOption('A'));
            this.DOM.optionB.addEventListener('click', () => this.selectOption('B'));
            this.DOM.aboutButton.addEventListener('click', () => this.DOM.aboutModal.classList.remove('hidden'));
            this.DOM.closeAboutModal.addEventListener('click', () => this.DOM.aboutModal.classList.add('hidden'));
        }

        nextRound() {
            if (this.state.round > 20) {
                this.endGame();
                return;
            }
            this.state.currentChoices = this.generateChoicePair();
            this.updateDisplay();
        }

        selectOption(optionKey) {
            if (!this.state.currentChoices) return;
            if (this.state.decayInterval) clearInterval(this.state.decayInterval);

            const selectedChoice = this.state.currentChoices[optionKey];
            this.state.activeDecayChoice = selectedChoice;
            this.DOM.activeBonusText.textContent = selectedChoice.display;

            if (selectedChoice.type === 'add') {
                // Choose an add rate per second (gentle scaling)
                this.state.activeAddRate = selectedChoice.value / 3; // units per second, calmer
            } else {
                this.state.activeAddRate = null;
            }

            const { A, B } = this.state.currentChoices;
            const optimalChoiceKey = A.getExpectedLogReturn() > B.getExpectedLogReturn() ? 'A' : 'B';
            if (optionKey === optimalChoiceKey) this.state.streak++;
            else this.state.streak = 0;

            if (this.state.decayStartTime) {
                this.state.totalTime += (Date.now() - this.state.decayStartTime) / 1000;
            }
            this.state.round++;
            this.startDecayProcess();
            this.nextRound();
        }

        startDecayProcess() {
            if (!this.state.activeDecayChoice) return;

            this.state.decayStartTime = Date.now();
            const decayLoop = () => {
                const now = Date.now();
                const elapsedTime = now - this.state.decayStartTime;
                const decay = Math.max(0, 1 - (elapsedTime / DECAY_MS));
                const dt = TICK_MS / 1000;

                if (this.state.activeAddRate != null) {
                    // Additive: add rate per second scaled by remaining decay
                    const delta = this.state.activeAddRate * decay * dt;
                    this.state.wealth += delta;
                } else {
                    // Multiplicative-style choices: sample per-second multiplier each tick,
                    // convert to per-dt using log-return scaling, and apply decay.
                    const m = this.state.activeDecayChoice.sample(); // per-second multiplier
                    let logR = Math.log(m);
                    // Safety clamp on logR to avoid rare blow-ups
                    const CLAMP = 0.01; // calm per-second cap on log-returns
                    if (logR > CLAMP) logR = CLAMP;
                    if (logR < -CLAMP) logR = -CLAMP;
                    const mult = Math.exp(logR * decay * dt);
                    this.state.wealth *= mult;
                }

                this.DOM.wealthDisplay.textContent = this.state.wealth.toFixed(2);
                this.updateWealthChart(elapsedTime / 1000);

                if (elapsedTime >= DECAY_MS) {
                    clearInterval(this.state.decayInterval);
                    this.state.decayInterval = null;
                    this.state.activeDecayChoice = null;
                    this.state.activeAddRate = null;
                }
            };
            this.state.decayInterval = setInterval(decayLoop, TICK_MS);
        }

        updateDisplay() {
            this.DOM.roundCounter.textContent = this.state.round;
            this.DOM.wealthDisplay.textContent = this.state.wealth.toFixed(2);
            this.DOM.streak.textContent = this.state.streak;

            if (!this.state.currentChoices) return;
            const { A, B } = this.state.currentChoices;
            
            const updateOptionUI = (option, id) => {
                const chartEl = this.DOM[`chart${id}`];
                const textEl = this.DOM[`textDisplay${id}`];
                const logReturnEl = this.DOM[`logReturn${id}`];

                if (option.type === 'pdf' || option.type === 'cdf') {
                    chartEl.classList.remove('hidden');
                    textEl.classList.add('hidden');
                    this.drawDistribution(chartEl, option);
                    logReturnEl.textContent = `E[log(R)] = ${option.getExpectedLogReturn().toFixed(3)}`;
                } else if (option.type === 'empirical') {
                    chartEl.classList.remove('hidden');
                    textEl.classList.add('hidden');
                    this.drawStockSeries(chartEl, option);
                    logReturnEl.textContent = `Empirical E[log(R)] = ${option.getExpectedLogReturn().toFixed(3)}`;
                } else {
                    chartEl.classList.add('hidden');
                    textEl.classList.remove('hidden');
                    textEl.textContent = option.display;
                    logReturnEl.textContent = option.type === 'add' ? `Value: ${option.value}` : `E[log(R)] = ${option.getExpectedLogReturn().toFixed(3)}`;
                }
            };
            updateOptionUI(A, 'A');
            updateOptionUI(B, 'B');
        }

        generateChoicePair() {
            const choiceTypes = ['pdf', 'add', 'multiply', 'cdf', 'empirical'];
            const selectedType = choiceTypes[Math.floor(Math.random() * choiceTypes.length)];
            let choiceA, choiceB;
            if (selectedType === 'pdf' || selectedType === 'cdf') {
                choiceA = this.choiceFactory.generateMultiplierPdfChoice();
                choiceB = this.choiceFactory.generateMultiplierPdfChoice();
                if (selectedType === 'cdf') {
                    choiceA.type = 'cdf';
                    choiceB.type = 'cdf';
                }
            } else if (selectedType === 'empirical') {
                choiceA = this.choiceFactory.generateEmpiricalStockChoice();
                choiceB = this.choiceFactory.generateEmpiricalStockChoice();
            } else if (selectedType === 'add') {
                choiceA = this.choiceFactory.generateAdditionChoice();
                choiceB = this.choiceFactory.generateAdditionChoice();
            } else if (selectedType === 'multiply') {
                choiceA = this.choiceFactory.generateSimpleMultiplierChoice();
                choiceB = this.choiceFactory.generateSimpleMultiplierChoice();
            }
            if (choiceA.getExpectedLogReturn() === choiceB.getExpectedLogReturn()) return this.generateChoicePair();
            return { A: choiceA, B: choiceB };
        }

        drawDistribution(canvas, distribution) {
            const ctx = canvas.getContext('2d');
            this.syncCanvasSize(canvas);
            const { width, height } = canvas;
            ctx.clearRect(0, 0, width, height);
            const { xs, ps, cdf, type } = distribution;
            const margin = { top: 10, right: 10, bottom: 20, left: 10 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            const dataToDraw = type === 'cdf' ? cdf : ps;
            const maxVal = type === 'cdf' ? 1 : Math.max(...ps);
            const minXs = xs[0], maxXs = xs.at(-1);
            ctx.beginPath();
            ctx.strokeStyle = type === 'cdf' ? this.getCssVar('--secondary-color') : this.getCssVar('--primary-color');
            ctx.lineWidth = 2;
            for (let i = 0; i < xs.length; i++) {
                const x = margin.left + ((xs[i] - minXs) / (maxXs - minXs)) * plotWidth;
                const y = height - margin.bottom - (dataToDraw[i] / maxVal) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            if (minXs < 0 && maxXs > 0) {
                const breakEvenX = margin.left + (-minXs / (maxXs - minXs)) * plotWidth;
                ctx.strokeStyle = this.getCssVar('--error-color');
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(breakEvenX, margin.top);
                ctx.lineTo(breakEvenX, height - margin.bottom);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        drawStockSeries(canvas, stockChoice) {
            const ctx = canvas.getContext('2d');
            this.syncCanvasSize(canvas);
            const { width, height } = canvas;
            ctx.clearRect(0, 0, width, height);
            const { prices } = stockChoice;
            const margin = { top: 10, right: 10, bottom: 20, left: 10 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            const minP = Math.min(...prices);
            const maxP = Math.max(...prices);
            ctx.beginPath();
            ctx.strokeStyle = this.getCssVar('--primary-color');
            ctx.lineWidth = 2;
            for (let i = 0; i < prices.length; i++) {
                const x = margin.left + (i / (prices.length - 1)) * plotWidth;
                const y = height - margin.bottom - ((prices[i] - minP) / (maxP - minP || 1)) * plotHeight;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        getCssVar(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '#fff';
        }

        syncCanvasSize(canvas) {
            const w = canvas.clientWidth || canvas.offsetWidth || 300;
            const h = canvas.clientHeight || canvas.offsetHeight || 150;
            if (canvas.width !== w) canvas.width = w;
            if (canvas.height !== h) canvas.height = h;
        }

        setupWealthChart() {
            const ctx = this.DOM.wealthChart.getContext('2d');
            const textColor = this.getCssVar('--text-color');
            this.wealthChartInstance = new Chart(ctx, {
                type: 'line',
                data: { 
                    datasets: [{
                        label: 'Your Wealth',
                        data: this.wealthHistory,
                        borderColor: '#00aaff',
                        tension: 0.1,
                        pointRadius: 0,
                        parsing: false
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { type: 'logarithmic', ticks: { color: textColor }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        x: { type: 'linear', title: { display: true, text: 'Time (s)' }, ticks: { color: textColor }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        updateWealthChart(timeElapsedSinceChoice) {
            const newTime = this.state.totalTime + timeElapsedSinceChoice;
            this.wealthHistory.push({ x: +newTime.toFixed(2), y: this.state.wealth });
            if (this.wealthHistory.length > 300) this.wealthHistory.shift();
            this.wealthChartInstance.update('none');
        }

        endGame() {
            if (this.state.decayInterval) clearInterval(this.state.decayInterval);
            const finalWealth = this.state.wealth;
            this.gameContainer.innerHTML = `
                <div class="game-over-screen">
                    <h1>Game Over!</h1>
                    <h3>Final Wealth: ${finalWealth.toFixed(2)}</h3>
                    <br>
                    <button id="play-again">Play Again</button>
                </div>
            `;
            document.getElementById('play-again').addEventListener('click', () => this.startGame());
        }
    }

    new Game();
    </script>
</body>
</html>
